---
# Role: open_web_ports
# Purpose: Ensure the master VM accepts inbound connections on TCP ports 80/443
# Compatible with CentOS Stream 9 (nftables backend via firewalld) and generic iptables.

- name: Detect OS facts
  ansible.builtin.setup:
    gather_subset:
      - '!all'
      - '!min'
      - os_family
      - distribution
  register: _facts

- name: Check if firewalld is installed
  ansible.builtin.shell: rpm -q firewalld >/dev/null 2>&1 && echo present || echo absent
  register: _firewalld_pkg
  changed_when: false
  failed_when: false

- name: Check if firewalld is running
  ansible.builtin.shell: systemctl is-active --quiet firewalld && echo active || echo inactive
  register: _firewalld_active
  changed_when: false
  failed_when: false

- name: Decide firewall backend
  ansible.builtin.set_fact:
    _fw_backend_effective: >-
      {{
        firewall_backend if firewall_backend != 'auto' else (
          'firewalld' if _firewalld_pkg.stdout == 'present' else 'iptables'
        )
      }}

- name: Normalize open_ports input (parse strings and coerce to list)
  ansible.builtin.set_fact:
    _open_ports_parsed: "{{ open_ports if (open_ports is sequence and open_ports is not string) else (open_ports | from_yaml) }}"

- name: Ensure open_ports is a list
  ansible.builtin.set_fact:
    _open_ports_list: "{{ _open_ports_parsed if (_open_ports_parsed is sequence and _open_ports_parsed is not string) else [_open_ports_parsed] }}"

- name: Open ports via firewalld (permanent)
  when: _fw_backend_effective == 'firewalld'
  block:
    - name: Ensure firewalld is running
      ansible.builtin.service:
        name: firewalld
        state: started
        enabled: true

    - name: Add ports to firewalld permanent config (idempotent)
      ansible.builtin.shell: |
        if ! firewall-cmd --permanent --query-port={{ item }}/tcp >/dev/null 2>&1; then
          firewall-cmd --permanent --add-port={{ item }}/tcp
          echo CHANGED
        else
          echo OK
        fi
      register: _fw_add_port
      changed_when: "'CHANGED' in _fw_add_port.stdout"
      loop: "{{ _open_ports_list }}"

    - name: Determine if any firewalld port changed
      ansible.builtin.set_fact:
        _fw_any_changed: "{{ _fw_add_port.results | selectattr('stdout','search','CHANGED') | list | length > 0 }}"

    - name: Reload firewalld to apply changes
      ansible.builtin.command: firewall-cmd --reload
      when: _fw_any_changed | bool
      changed_when: true

    - name: Show active firewalld ports
      ansible.builtin.command: firewall-cmd --list-ports
      register: _fw_ports
      changed_when: false

- name: Open ports via iptables/nftables (fallback)
  when: _fw_backend_effective != 'firewalld'
  block:
    - name: Ensure iptables-services package is present (if available)
      ansible.builtin.shell: |
        if command -v dnf >/dev/null 2>&1; then
          dnf -y install iptables-services || true
        elif command -v yum >/dev/null 2>&1; then
          yum -y install iptables-services || true
        fi
        echo done
      register: _iptables_pkg
      changed_when: false
      failed_when: false

    - name: Create systemd unit to persist iptables rules
      ansible.builtin.copy:
        dest: /etc/systemd/system/ajasta-iptables-ports.service
        mode: '0644'
        content: |
          [Unit]
          Description=Ajasta iptables rules for web ports
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          {% for p in _open_ports_list %}
          ExecStart=/usr/sbin/iptables -I INPUT -p tcp --dport {{ p }} -j ACCEPT
          {% endfor %}
          {% for p in _open_ports_list %}
          ExecStop=/usr/sbin/iptables -D INPUT -p tcp --dport {{ p }} -j ACCEPT
          {% endfor %}

          [Install]
          WantedBy=multi-user.target

    - name: Enable and start iptables ports service
      ansible.builtin.systemd:
        name: ajasta-iptables-ports.service
        enabled: true
        state: started
        daemon_reload: true

    - name: Show iptables INPUT rules (grep 80/443)
      ansible.builtin.shell: iptables -S INPUT | grep -E -- "--dport (80|443)" || true
      register: _iptables_rules
      changed_when: false
      failed_when: false

    - name: Show kube-proxy NAT rules related to external IP:80 (best-effort)
      ansible.builtin.shell: |
        iptables -t nat -S | grep -F "{{ hostvars[groups['k8s_master'][0]].ansible_host | default('') }}" | grep -F "dpt:80" || true
      register: _nat_rules
      changed_when: false
      failed_when: false

- name: Set KUBECONFIG for optional Kubernetes diagnostics
  ansible.builtin.set_fact:
    _env_kube:
      KUBECONFIG: "{{ kubeconfig_path }}"

- name: Optionally fetch ingress-nginx NodePort for HTTP(80)
  ansible.builtin.shell: |
    kubectl -n ingress-nginx get svc ingress-nginx-controller -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null | tr -d '\n'
  environment: "{{ _env_kube }}"
  register: _controller_http_nodeport
  changed_when: false
  failed_when: false

- name: Ensure socat is installed when local port80 proxy is enabled
  when: enable_local_port80_proxy | bool
  ansible.builtin.shell: |
    set -e
    if command -v socat >/dev/null 2>&1; then echo ok; exit 0; fi
    if command -v dnf >/dev/null 2>&1; then dnf -y install socat; echo installed; exit 0; fi
    if command -v yum >/dev/null 2>&1; then yum -y install socat || yum -y install nmap-ncat; echo installed; exit 0; fi
    if command -v apt-get >/dev/null 2>&1; then apt-get update && apt-get -y install socat; echo installed; exit 0; fi
    echo "socat_not_installed" && exit 1
  register: _socat_install
  changed_when: '"installed" in _socat_install.stdout'

- name: Create systemd unit to proxy 0.0.0.0:80 -> 127.0.0.1:NodePort (socat)
  when: enable_local_port80_proxy | bool and (_controller_http_nodeport.stdout | length) > 0
  ansible.builtin.copy:
    dest: /etc/systemd/system/ajasta-port80-proxy.service
    mode: '0644'
    content: |
      [Unit]
      Description=Ajasta local port 80 proxy to ingress NodePort
      After=network-online.target
      Wants=network-online.target

      [Service]
      Type=simple
      ExecStart=/usr/bin/socat TCP-LISTEN:80,reuseaddr,fork TCP:127.0.0.1:{{ _controller_http_nodeport.stdout }}
      Restart=always
      RestartSec=2

      [Install]
      WantedBy=multi-user.target

- name: Enable and start ajasta-port80-proxy
  when: enable_local_port80_proxy | bool and (_controller_http_nodeport.stdout | length) > 0
  ansible.builtin.systemd:
    name: ajasta-port80-proxy.service
    enabled: true
    state: restarted
    daemon_reload: true

- name: Verify local connectivity to Ingress from master (localhost)
  when: open_web_ports_check_local | bool or (enable_local_port80_proxy | bool)
  ansible.builtin.shell: |
    set -e
    # Try curl to localhost:80; return only HTTP status code or CURL error
    curl -sS -o /dev/null -w "HTTP %{http_code}\n" http://127.0.0.1/ || echo "curl_failed"
  register: _curl_local
  changed_when: false
  failed_when: false

- name: Capture listener on :80 (ss)
  when: enable_local_port80_proxy | bool
  ansible.builtin.shell: ss -tlnp | grep -E "\*:80 |127\.0\.0\.1:80 " || true
  register: _ss_port80
  changed_when: false
  failed_when: false

- name: Verify external connectivity using master public IP
  ansible.builtin.shell: |
    set -e
    MASTER_IP="{{ hostvars[groups['k8s_master'][0]].ansible_host | default('') }}"
    if [ -n "$MASTER_IP" ]; then
      curl --connect-timeout 3 --max-time 8 -sS -o /dev/null -w "HTTP %{http_code}\n" http://$MASTER_IP/ || echo "curl_failed"
    else
      echo "no_master_ip"
    fi
  register: _curl_external
  changed_when: false
  failed_when: false

- name: Verify NodePort fallback using master public IP (best-effort)
  ansible.builtin.shell: |
    set -e
    MASTER_IP="{{ hostvars[groups['k8s_master'][0]].ansible_host | default('') }}"
    NP="{{ _controller_http_nodeport.stdout | default('') }}"
    if [ -n "$MASTER_IP" ] && [ -n "$NP" ]; then
      curl --connect-timeout 3 --max-time 8 -sS -o /dev/null -w "HTTP %{http_code}\n" http://$MASTER_IP:$NP/ || echo "curl_failed"
    else
      echo "nodeport_unavailable"
    fi
  register: _curl_nodeport
  changed_when: false
  failed_when: false

- name: Compute external connectivity verdict
  ansible.builtin.set_fact:
    _external_pass: "{{ ((_curl_external.stdout | default('')) | regex_search('HTTP (2|3)')) is not none }}"

- name: Summary of firewall configuration
  ansible.builtin.debug:
    msg:
      - "Firewall backend used: {{ _fw_backend_effective }}"
      - "firewalld installed: {{ _firewalld_pkg.stdout }} active: {{ _firewalld_active.stdout }}"
      - "firewalld ports (if any): {{ _fw_ports.stdout | default('n/a') }}"
      - "iptables rules (if any): {{ _iptables_rules.stdout | default('n/a') }}"
      - "kube-proxy NAT rules (best-effort): {{ _nat_rules.stdout | default('n/a') }}"
      - "ss -tlnp port 80 (if proxy enabled): {{ _ss_port80.stdout | default('n/a') }}"
      - "curl localhost result (optional): {{ _curl_local.stdout | default('skipped') }}"
      - "curl external ({{ hostvars[groups['k8s_master'][0]].ansible_host | default('') }}) result: {{ _curl_external.stdout | default('n/a') }}"
      - "curl NodePort fallback (if available) result: {{ _curl_nodeport.stdout | default('n/a') }}"
      - "External connectivity verdict: {{ 'PASS' if _external_pass else 'CHECK CLOUD SG/INGRESS' }}"
      - "Note: localhost:80 may be closed when using Service externalIPs; external IP curl is the canonical check."
